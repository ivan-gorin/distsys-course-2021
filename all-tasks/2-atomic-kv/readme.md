# Atomic KV

Вам дана [наивная реализация](kv/node/main.cpp) небольшого KV хранилища с операциями `Set(key, value)` и `Get(key)`:

- Координатор операции `Set(key, value)` выбирает временную метку (`WriteTimestamp`) для записи с помощью локальных часов и синхронно записывает `value` с этой временной меткой (`StampedValue`) на кворум из большинства узлов.


- Координатор операции `Get(key)` собирает версионированные значения для ключа `key` с кворума и выбирает из них значение с максимальной временной меткой.

Такая реализация не гарантирует [линеаризуемость](https://jepsen.io/consistency/models/linearizable).

Ваша задача – доработать протокол репликации и добиться линеаризуемого поведения. 

Для этого:

- Добавьте в операцию чтения фазу записи: она будет гарантировать, что последующие чтения не смогут прочитать более старое значение.
- Реализуйте надежную процедуру генерации монотонных временных меток для записей. 

## Алгоритм Attiya-Bar-Noy-Dolev (ABD)

- [Notes on Theory of Distributed Systems](https://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf) – Chapter 16 – _Distributed Shared Memory_
- [Лекции Мартинка Клеппмана](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)
- [Оригинальная статья](https://groups.csail.mit.edu/tds/papers/Attiya/TM-423.pdf)

## Генерация временных меток

Координаторы записей должны генерировать для них монотонные временные метки: 

_Если запись _W_ завершилась в физическом времени до начала записи _W'_, то временная метка для записи _W'_ должна быть строго больше метки для _W_._

Это требование естественно следует из выбранной модели согласованности:
- Для реплик порядок записей определяется порядком временных меток, выбранных координаторами записей. 
- Клиенты могут наблюдать порядок записей в физическом времени, устанавливая между ними причинность.

Задача системы – учитывать причинность операций клиентов, и это можно сделать неявно, согласовав логический порядок записей внутри системы с физическим временем.

### Настенные часы

В данной вам реализации координатор записи в качестве временной метки использует показания своих локальных часов:

```cpp
WriteTimestamp ChooseWriteTimestamp() const {
  return {whirl::node::rt::WallTimeNow().ToJiffies().Count()};
}
```

Если часы на координаторе записи _W_ спешили, а на координаторе _W'_ – отставали, то порядок этих записей для реплик (порядок на временных метках) будет расходиться с порядком операций в физическом времени (порядок для клиентов), и линеаризуемость будет нарушена.

Реализуйте один из двух надежных способов генерации временных меток:

### Логические часы

Добавьте в `Set` фазу кворумного чтения, и из полученных ответов генерируйте свежую временную метку для записи.

Иными словами, замените ненадежные физические часы на надежные _логические_.

### Google TrueTime

Используйте [TrueTime](https://gitlab.com/whirl-framework/whirl-frontend/-/blob/master/whirl/node/time/true_time_service.hpp):

```cpp
// [tt_now.earliest, tt_now.latest]
auto tt_now = whirl::node::rt::TrueTime()->Now();
```

В отличие от обычных часов, вызов `Now` в TrueTime возвращает _интервал_, в котором гарантированно содержится истинный _now_.

От вызова к вызову интервал может произвольно меняться, никаких гарантий относительно монотонности его границ нет. Единственная гарантия – интервал содержит время вызова `Now`.

Придумайте, как можно использовать эту гарантию в задаче генерации временных меток.

#### TrueTime в Spanner

[Spanner: Google's Globally-Distributed Database](https://research.google/pubs/pub39966/)

TrueTime позволяет узлам-координаторам транзакций в Spanner генерировать глобально монотонные временные метки _локально_, не обращаясь к централизованному timestamp oracle-у.

## Версионированное хранилище

Каждая реплика должна хранить значения в локальной базе данных, которая доступна через интерфейс `IDatabase`.

Для каждого ключа база данных хранит только одно значение, что не слишком хорошо подходит нашему алгоритму репликации, 
в котором у каждой записи есть версия.

Подумайте, как с помощью снимков состояния (`MakeSnapshot`) и итераторов реализовать поверх `IDatabase` _мульти-версионное_ хранилище,
которое позволит репликам записывать / читать версионированные значения без дополнительной синхронизации.

Вероятно вашей реализации потребуется сборка мусора.

## Отказоустойчивость

Ваша реализация должна переживать рестарты узлов и отказ произвольного меньшинства узлов.

## Замечания по реализации

### Роли и сервисы

Каждый узел в алгоритме ABD играет две _роли_:

- _Координатор_ клиентской операции: генерирует временные метки, собирает кворумы, отвечает клиенту.
- _Реплика_: обслуживает команды на запись / чтение от координаторов.

В коде эти роли представлены двумя отдельными RPC-сервисами: `Coordinator` и `Replica` соответственно.

### Контексты

Используйте `await::context::Scope` или `await::context::StopScope` для управления отменой RPC в пределах фазы алгоритма ABD. 


