# Multi-Paxos

## Пролог


_There are only two hard problems in distributed systems: 2. Exactly-once delivery 1. Guaranteed order of messages 2. Exactly-once delivery_

[Источник](https://twitter.com/mathiasverraes/status/632260618599403520)

## Задача

Реализуйте отказоустойчивый линеаризуемый RSM (_replicated state machine_) с помощью протокола репликации Multi-Paxos.

## Участники

- _Реплики_ RSM – реплицируют _автомат_
- _Клиенты_ – посылают репликам RSM свои _команды_
- _Прокси_ – посредники между клиентами и репликами RSM

### Прокси

Реплика RSM не всегда способна применить полученную от пользователя команду:
- Реплика может оказаться follower-ом и перенаправить клиента на лидера.
- Может быть реплика была исключена из RSM после переконфигурации и больше не может коммитить в лог команды.

Узлы-прокси знают про подобные сценарии и скрывают внутренний протокол RSM от внешнего клиента.

Клиент, таким образом, просто ретраит свой запрос на прокси до тех пор, пока ему не ответят.

## Команда

Клиент отправляет в RSM _команды_ – [`Command`](rsm/client/command.hpp).

Поле | Описание
--- | ---
`type` | Тип пользовательской операции (например, `Get`, `Set` или `Cas`). Устанавливается внешним клиентом, интерпретируется автоматом, для реплики непрозрачен.
`request` | Сериализованный запрос пользовательской операции (например, пара (`key`, `value`) для операции `Set`). Интерпретируется автоматом, для реплики непрозрачен.
`request_id` | Глобально уникальный идентификатор для реализации семантики exactly-once. Генерируется внешним клиентом.
`readonly` | `true` – читающая операция, `false` – мутация автомата

## Автомат

Реплицируемое состояние в RSM представлено в виде _автомата_ – [`IStateMachine`](rsm/replica/state_machine.hpp).

Автомат умеет применять команды (интерпретировать поле `request` у `Command` с помощью поля `type`) и возвращать результат (так же в сериализованном виде).

Автомат однопоточный, вызывать на нем `Apply` можно только последовательно.

Семантика команд и реализация автомата реплике неизвестны.

Кроме применения команд, автомат умеет создавать (`MakeSnapshot`) и устанавливать (`InstallSnapshot`) снимки состояния. Подробности – в пункте "Персистентность".

## Реплика

Реплика получает от прокси клиентские команды и в ответ посылает [`Response`](rsm/replica/response.hpp):
- `Ack` с сериализованным ответом от автомата, если команда была успешна зафиксирована в логе и применена.
- `RedirectToLeader` – реплика отказывается обслуживать команду, так как не является лидером в RSM, и перенаправляет клиента к лидеру.
- `NotALeader` – реплика не знает, кто является лидером, не может применить команду и предлагает прокси повторить попытку на другой реплике.

## Multi-Paxos

Протокол Multi-Paxos детально не описан, так что вы можете пробовать свои собственные оптимизации (конечно, если они не нарушают safety).

- [The Part-Time Parliament](https://lamport.azurewebsites.net/pubs/lamport-paxos.pdf)
- [Paxos Lecture](https://www.youtube.com/watch?v=JEpsBg0AO6o) by Diego Ongaro, John Ousterhout + [слайды](https://ongardie.net/static/raft/userstudy/paxos.pdf)

## Персистентность

### Лог

Каждая реплика поддерживает лог команд – [`Log`](rsm/replica/store/log.hpp), состоящий из записей – [`LogEntry`](rsm/replica/store/log_entry.hpp).

Каждая запись в логе хранит состояние acceptor-а из алгоритма Single-Decree Paxos.

Класс `Log` – простая обертка над реализацией интерфейса [`persist::rsm::multipaxos::IRandomAccessLog`](https://gitlab.com/whirl-framework/persist/-/blob/master/persist/rsm/multipaxos/log/log.hpp), изучите его возможности.

Интерфейс `IRandomAccessLog` не предполагает конкурентного доступа. Если вы собираетесь обращаться к логу из разных потоков / файберов, то должны самостоятельно продумать синхронизацию.

### Компактификация лога и снимки состояния

В алгоритме Multi-Paxos / RAFT лог растет бесконечно, что не очень практично:
1) Рано или поздно он переполнит диск.
2) Длинный лог замедляет восстановление реплики после рестарта.

Чтобы ограничить расход места на диске, реплики RSM должны периодически обрезать зафиксированный и примененный префикс лога и заменять его на _снимок состояния_ (_snapshot_).

Персистентное состояние RSM, таким образом, образовано
1) суффиксом лога команд и 
2) снимком состояния для отрезанного префикса.

Отрезать префикс от `IRandomAccessLog` можно с помощью метода `TruncatePrefix`.

Автомат умеет фиксировать свое текущее состояние с помощью метода `MakeSnapshot` и устанавливать его с помощью метода `InstallSnapshot`.

Для простоты мы считаем, что создание и установка снимка автомата – синхронные операции.

Подумайте, какие данные должны войти в снимок состояния RSM помимо снимка состояния автомата.

Директорию для хранения лога / снимков состояния можно узнать из конфига по ключу `rsm.store.dir`.

Если вы используете `TruncatePrefix`, то используйте [сегментированный лог](https://gitlab.com/whirl-framework/persist/-/blob/master/persist/rsm/multipaxos/log/segmented/log.hpp) в качестве реализации
интерфейса `IRandomAccessLog`.

## Exactly-once

Реплика RSM может получить клиентскую команду, закоммитить ее на кворум, применить к автомату, а потом сразу же упасть, так и не ответив прокси. А может перезагрузиться сразу после того, как получила команду, не успев ничего с ней сделать.

Узел-прокси эти сценарии не различает, он просто получает в ответ на свой RPC транспортную ошибку или таймаут, после чего отправляет команду другой реплике.

Новая реплика также мало что понимает: например, в ее логе команды нет, но может быть реплика просто не вошла в кворум, на который эта команда была ранее закоммичена.

Тем не менее, RSM должен обеспечить клиенту семантику _exactly-once_:
- Несмотря на все ретраи, отправленная в RSM команда применится к автомату каждой из реплик только один раз.
- Клиент eventually получит от RSM результат ее применения.

### Протокол клиента, идентификаторы

Для обеспечения exactly-once RSM-у требуется помощь от клиента.

Будем считать, что клиенты – однопоточные и синхронные, т.е. у одного клиента может быть только один outstanding запрос.

Для каждой отправляемой в RSM команды клиент генерирует глобально-уникальный идентификатор, состоящий из двух полей:
- Идентификатор клиента
- Порядковый номера запроса на этом клиенте

Каждый ретрай команды на прокси / на клиенте сохраняет этот идентификатор.

### Требование к реализации

Объем дополнительных данных, которые реплики должны поддерживать для обеспечения exactly-once, не должен зависеть от количества выполняемых команд, но может зависеть от количества клиентов RSM.

## Чтения

Читающие операции можно линеаризовать относительно мутаций, но при этом не проводить их через консенсус / фиксировать в логе.

Есть два основных способа это делать:

### Quorum reads

Реплика, обслуживающая чтение, синхронно общается с кворумом (без записи в лог команд), выбирает слот для линеаризации чтения и локально ждет коммита + применения мутации из этого слота, после чего выполняет чтение относительно локального автомата.

### Leader leases

Если гарантировать, что лидеры не пересекаются во времени, то можно читать с лидера без коммуникации с другими узлами. 

С одной стороны, мы сокращаем время обслуживания чтений, но с другой ставим линеаризуемость системы в зависимость от поведения часов.

### Полезные ссылки
- [Linearizable Quorum Reads in Paxos](https://www.usenix.org/system/files/hotstorage19-paper-charapko.pdf)
- [Paxos Quorum Leases: Fast Reads Without Sacrificing Writes](https://www.cs.cmu.edu/~dga/papers/leases-socc2014.pdf)

## Выбор лидера

В отличие от алгоритма RAFT, где RSM не может обслуживать запросы без лидера, в Multi-Paxos лидер – это всего лишь оптимизация.

Лидером может быть выбран любой узел, даже с пустым логом, фаза _Prepare_ протокола Single-Decree Paxos позволит ему узнать про все ранее зафиксированные в логе команды.

Multi-Paxos переживает конкуренцию лидеров: можно сказать, что Single-Decree Paxos как раз и нужен для того, чтобы обеспечить safety в таком сценарии.

## План действий

1) Реализуйте наивный вариант Multi-Paxos с отдельным двухфазным Single-Decree Paxos внутри каждого слота, без выбора лидера.
2) Реализуйте семантику exactly-once для ретраев на клиенте / прокси.
3) [_Бонусный уровень_] Реализуйте выбор лидера.
4) [_Бонусный уровень_] Обрезайте лог и сохраняйте снимки состояния.
5) [_Бонусный уровень_] Реализуйте чтения в обход лога / консенсуса.

Вам разрешается менять только содержимое директории rsm/replica.

Основная логика реплики находится в классе [`MultiPaxos`](rsm/replica/multipaxos.cpp).

## Замечания по реализации Multi-Paxos

Каждая команда проходит на реплике через конвейер:
1) Назначена в слот лога
2) Закоммичена в слот консенсусом
3) Применена к автомату

Второй этап для разных команд может выполняться параллельно, а первый (выкладывание команд в лог) и третий (применение команд) этапы по своему смыслу последовательные.

Подумайте, как выразить эти этапы с помощью инструментов библиотеки await.

Для передачи команд / закоммиченных индексов между файберами используйте [каналы](https://gitlab.com/Lipovsky/await/-/blob/master/await/fibers/sync/channel.hpp).

## Тесты

В тестах с помощью написанного вами RSM реплицируется небольшое [in-memory KV хранилище](kv/store.hpp) с операциями `Get`, `Set` и `Cas`.

Поверх этого хранилища реализован разделяемый атомарный счетчик [`AtomicCounter`](tests/common/atomic_counter.hpp) с lock-free операцией `FetchAdd`.

Клиенты в тестах конкурентно увеличивают этот счетчик.

Симуляция считается успешной, если:
- Итоговое значение счетчика совпадает с общим количеством инкрементов всех клиентов.
- Все `FetchAdd`-ы клиентов вернули разные значения.

В первом наборе тестов узлы не перезагружаются и не умирают, так что можно считать, что в нем нет ретраев, а значит его можно пройти без реализации семантики exactly-once.
